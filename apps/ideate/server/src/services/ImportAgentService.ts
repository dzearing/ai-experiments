import { query, type SDKAssistantMessage } from '@anthropic-ai/claude-code';
import { ThingService, type CreateThingInput, type ThingMetadata } from './ThingService.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';
import { tmpdir, homedir } from 'os';

/**
 * Import request from the client
 */
export interface ImportRequest {
  sourceType: 'git' | 'local';
  gitUrl?: string;
  localPath?: string;
  instructions: string;
  targetThingId: string;
  workspaceId?: string;
  userId: string;
}

/**
 * Progress step for streaming to the client
 */
export interface ImportStep {
  id: string;
  label: string;
  status: 'pending' | 'running' | 'complete' | 'error';
  detail?: string;
}

/**
 * Callbacks for streaming import progress
 */
export interface ImportCallbacks {
  onStepStart: (step: { id: string; label: string }) => void;
  onStepUpdate: (stepId: string, update: { status?: ImportStep['status']; detail?: string }) => void;
  onStepComplete: (stepId: string, detail?: string) => void;
  onStepError: (stepId: string, error: string) => void;
  onComplete: (createdThings: ThingMetadata[]) => void;
  onError: (error: string) => void;
}

/**
 * Thing plan generated by Claude
 */
interface ThingPlan {
  name: string;
  description?: string;
  type?: 'category' | 'project' | 'feature' | 'item';
  tags?: string[];
  children?: ThingPlan[];
}

/**
 * Service for running the import agent.
 * Uses Claude to analyze sources and create Things based on user instructions.
 */
export class ImportAgentService {
  private thingService: ThingService;
  private abortController: AbortController | null = null;

  constructor() {
    this.thingService = new ThingService();
  }

  /**
   * Cancel the current import operation
   */
  cancel(): void {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }

  /**
   * Run the import process
   */
  async runImport(request: ImportRequest, callbacks: ImportCallbacks): Promise<void> {
    this.abortController = new AbortController();
    const createdThings: ThingMetadata[] = [];
    let stepCounter = 0;

    const nextStepId = () => `step-${++stepCounter}`;

    try {
      // Step 1: Access source
      const accessStepId = nextStepId();
      const displayPath = request.sourceType === 'git'
        ? request.gitUrl!
        : request.localPath!;
      const dirName = path.basename(displayPath.replace(/\/$/, ''));

      callbacks.onStepStart({
        id: accessStepId,
        label: request.sourceType === 'git'
          ? `Cloning "${dirName}"...`
          : `Scanning "${dirName}"...`
      });

      let sourceContent: string;
      let sourcePath: string;
      let scanResult: { content: string; folderCount: number; fileCount: number };

      if (request.sourceType === 'git') {
        // Clone git repo to temp directory
        const tempDir = path.join(tmpdir(), `import-${Date.now()}`);
        await fs.mkdir(tempDir, { recursive: true });

        try {
          callbacks.onStepUpdate(accessStepId, { detail: `Downloading from ${request.gitUrl}...` });
          execSync(`git clone --depth 1 "${request.gitUrl}" "${tempDir}"`, {
            timeout: 60000,
            stdio: 'pipe',
          });
          sourcePath = tempDir;
          scanResult = await this.getDirectoryStructure(tempDir);
          sourceContent = scanResult.content;
          callbacks.onStepComplete(accessStepId, `Found ${scanResult.folderCount} folders, ${scanResult.fileCount} files`);
        } catch (error) {
          callbacks.onStepError(accessStepId, `Failed to clone: ${error instanceof Error ? error.message : 'Unknown error'}`);
          throw error;
        }
      } else {
        // Local path - expand ~ to home directory
        sourcePath = request.localPath!.replace(/^~/, homedir());
        try {
          const stat = await fs.stat(sourcePath);
          if (stat.isDirectory()) {
            scanResult = await this.getDirectoryStructure(sourcePath);
            sourceContent = scanResult.content;
            callbacks.onStepComplete(accessStepId, `Found ${scanResult.folderCount} folders, ${scanResult.fileCount} files`);
          } else {
            const content = await fs.readFile(sourcePath, 'utf-8');
            sourceContent = `File: ${path.basename(sourcePath)}\n\nContent:\n${content.slice(0, 10000)}`;
            callbacks.onStepComplete(accessStepId, `Read file: ${path.basename(sourcePath)}`);
          }
        } catch (error) {
          callbacks.onStepError(accessStepId, `Failed to access: ${error instanceof Error ? error.message : 'Unknown error'}`);
          throw error;
        }
      }

      if (this.abortController?.signal.aborted) {
        throw new Error('Import cancelled');
      }

      // Step 2: Analyze with Claude
      const analyzeStepId = nextStepId();
      callbacks.onStepStart({ id: analyzeStepId, label: 'Planning Thing structure...' });

      const plan = await this.analyzeWithClaude(sourceContent, request.instructions, callbacks, analyzeStepId);

      if (this.abortController?.signal.aborted) {
        throw new Error('Import cancelled');
      }

      const thingCount = this.countThingsInPlan(plan);
      callbacks.onStepComplete(analyzeStepId, `Planned ${thingCount} Thing${thingCount !== 1 ? 's' : ''} to create`);

      // Step 3: Create Things
      const createStepId = nextStepId();
      callbacks.onStepStart({ id: createStepId, label: 'Creating Things...' });

      await this.createThingsFromPlan(
        plan,
        request.targetThingId,
        request.userId,
        request.workspaceId,
        createdThings,
        callbacks,
        createStepId
      );

      callbacks.onStepComplete(createStepId, `Created ${createdThings.length} Things`);

      // Clean up temp directory if git
      if (request.sourceType === 'git' && sourcePath.startsWith(tmpdir())) {
        try {
          await fs.rm(sourcePath, { recursive: true, force: true });
        } catch {
          // Ignore cleanup errors
        }
      }

      callbacks.onComplete(createdThings);
    } catch (error) {
      if ((error as Error).message === 'Import cancelled') {
        callbacks.onError('Import cancelled by user');
      } else {
        callbacks.onError(error instanceof Error ? error.message : 'Unknown error');
      }
    } finally {
      this.abortController = null;
    }
  }

  /**
   * Get a summary of directory structure with counts
   */
  private async getDirectoryStructure(
    dirPath: string,
    depth = 0,
    maxDepth = 3,
    counts = { folders: 0, files: 0 }
  ): Promise<{ content: string; folderCount: number; fileCount: number }> {
    if (depth > maxDepth) {
      return { content: '', folderCount: counts.folders, fileCount: counts.files };
    }

    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    const lines: string[] = [];
    const indent = '  '.repeat(depth);

    // Filter out common non-essential directories
    const filteredEntries = entries.filter(e => {
      const name = e.name;
      return !['node_modules', '.git', '.next', 'dist', 'build', '__pycache__', '.venv', 'venv'].includes(name);
    });

    for (const entry of filteredEntries.slice(0, 50)) { // Limit entries per directory
      if (entry.isDirectory()) {
        counts.folders++;
        lines.push(`${indent}ðŸ“ ${entry.name}/`);
        const subResult = await this.getDirectoryStructure(
          path.join(dirPath, entry.name),
          depth + 1,
          maxDepth,
          counts
        );
        if (subResult.content) lines.push(subResult.content);
      } else {
        counts.files++;
        lines.push(`${indent}ðŸ“„ ${entry.name}`);
      }
    }

    if (filteredEntries.length > 50) {
      lines.push(`${indent}... and ${filteredEntries.length - 50} more entries`);
    }

    return {
      content: lines.join('\n'),
      folderCount: counts.folders,
      fileCount: counts.files,
    };
  }

  /**
   * Analyze source with Claude to generate a Thing plan
   */
  private async analyzeWithClaude(
    sourceContent: string,
    instructions: string,
    callbacks: ImportCallbacks,
    stepId: string
  ): Promise<ThingPlan[]> {
    callbacks.onStepUpdate(stepId, { detail: 'Analyzing file structure...' });

    const prompt = `You are a JSON generator. You MUST output ONLY valid JSON with no other text.

TASK: Analyze this source content and create a hierarchical structure of "Things" based on user instructions.

SOURCE CONTENT:
${sourceContent}

USER INSTRUCTIONS:
${instructions}

OUTPUT FORMAT (required schema):
[
  {
    "name": "string (required)",
    "description": "string (optional)",
    "type": "category|project|feature|item (default: item)",
    "tags": ["array", "of", "strings"],
    "children": [/* nested Things with same schema */]
  }
]

CRITICAL: Your response must start with '[' and end with ']'. No explanations, no markdown, no text before or after the JSON array. Just the raw JSON array.`;

    try {
      const response = query({
        prompt,
        options: {
          model: 'sonnet',
          permissionMode: 'bypassPermissions',
          maxTurns: 1,
        },
      });

      let fullResponse = '';
      let lastUpdateTime = Date.now();
      const updateInterval = 500; // Update every 500ms

      for await (const message of response) {
        if (this.abortController?.signal.aborted) {
          throw new Error('Import cancelled');
        }

        if (message.type === 'assistant') {
          const assistantMsg = message as SDKAssistantMessage;
          const msgContent = assistantMsg.message.content;

          if (Array.isArray(msgContent)) {
            for (const block of msgContent) {
              if (block.type === 'text') {
                fullResponse += block.text;

                // Provide progress updates while streaming
                const now = Date.now();
                if (now - lastUpdateTime > updateInterval) {
                  // Count how many "name" fields we've seen so far
                  const nameMatches = fullResponse.match(/"name"\s*:/g);
                  const thingCount = nameMatches ? nameMatches.length : 0;
                  if (thingCount > 0) {
                    callbacks.onStepUpdate(stepId, {
                      detail: `Building plan... (${thingCount} Thing${thingCount !== 1 ? 's' : ''} found)`
                    });
                  }
                  lastUpdateTime = now;
                }
              }
            }
          } else if (typeof msgContent === 'string') {
            fullResponse += msgContent;
          }
        } else if (message.type === 'result' && message.subtype === 'success' && message.result) {
          if (!fullResponse) {
            fullResponse = message.result;
          }
        }
      }

      // Parse the JSON response
      let jsonStr = fullResponse.trim();

      console.log('[ImportAgentService] Raw response (first 500 chars):', jsonStr.slice(0, 500));

      // Try to extract JSON from markdown code blocks
      const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1].trim();
      }

      // Try to find array directly (handle text before/after JSON)
      const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
      if (arrayMatch) {
        jsonStr = arrayMatch[0];
      }

      // If still no valid JSON, throw with helpful error
      if (!jsonStr.startsWith('[')) {
        console.error('[ImportAgentService] Response does not contain JSON array:', jsonStr.slice(0, 200));
        throw new Error('Claude did not return valid JSON. Please try again.');
      }

      const plan: ThingPlan[] = JSON.parse(jsonStr);
      return plan;
    } catch (error) {
      console.error('[ImportAgentService] Failed to analyze with Claude:', error);
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to analyze source: ${errorMsg}`);
    }
  }

  /**
   * Count total Things in a plan (including nested)
   */
  private countThingsInPlan(plans: ThingPlan[]): number {
    let count = 0;
    for (const plan of plans) {
      count++;
      if (plan.children) {
        count += this.countThingsInPlan(plan.children);
      }
    }
    return count;
  }

  /**
   * Create Things from a plan recursively
   */
  private async createThingsFromPlan(
    plans: ThingPlan[],
    parentId: string,
    userId: string,
    workspaceId: string | undefined,
    createdThings: ThingMetadata[],
    callbacks: ImportCallbacks,
    stepId: string
  ): Promise<void> {
    for (const plan of plans) {
      if (this.abortController?.signal.aborted) {
        throw new Error('Import cancelled');
      }

      callbacks.onStepUpdate(stepId, { detail: `Creating "${plan.name}"...` });

      const input: CreateThingInput = {
        name: plan.name,
        description: plan.description,
        type: plan.type || 'item',
        tags: plan.tags || [],
        parentIds: [parentId],
        workspaceId,
      };

      const created = await this.thingService.createThing(userId, input);
      createdThings.push(created);

      // Recursively create children
      if (plan.children && plan.children.length > 0) {
        await this.createThingsFromPlan(
          plan.children,
          created.id,
          userId,
          workspaceId,
          createdThings,
          callbacks,
          stepId
        );
      }
    }
  }
}
