---
phase: 04-permissions-modes
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/claude-code-web/client/src/types/agent.ts
  - apps/claude-code-web/client/src/hooks/useAgentStream.ts
  - apps/claude-code-web/client/src/components/PermissionDialog.tsx
  - apps/claude-code-web/client/src/components/PermissionDialog.module.css
  - apps/claude-code-web/client/src/components/AskUserDialog.tsx
  - apps/claude-code-web/client/src/components/ChatView.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Permission dialog appears when SDK requests tool approval"
    - "User can approve, deny, or approve-always for a tool"
    - "AskUserQuestion renders as questionnaire dialog using OpenQuestionsResolver"
    - "Permission response is POST'ed back to server"
    - "Dialog shows tool name and formatted input"
  artifacts:
    - path: "apps/claude-code-web/client/src/components/PermissionDialog.tsx"
      provides: "Tool approval dialog"
      exports: ["PermissionDialog"]
    - path: "apps/claude-code-web/client/src/components/AskUserDialog.tsx"
      provides: "AskUserQuestion dialog wrapper"
      exports: ["AskUserDialog"]
    - path: "apps/claude-code-web/client/src/types/agent.ts"
      provides: "Client permission event types"
      contains: "PermissionRequestEvent"
    - path: "apps/claude-code-web/client/src/hooks/useAgentStream.ts"
      provides: "Permission event handling"
      contains: "permission_request"
  key_links:
    - from: "apps/claude-code-web/client/src/hooks/useAgentStream.ts"
      to: "PermissionDialog"
      via: "state update on permission_request event"
      pattern: "setPermissionRequest"
    - from: "apps/claude-code-web/client/src/components/PermissionDialog.tsx"
      to: "/api/agent/permission-response"
      via: "fetch POST on approve/deny"
      pattern: "permission-response"
    - from: "apps/claude-code-web/client/src/components/AskUserDialog.tsx"
      to: "OpenQuestionsResolver"
      via: "import and render"
      pattern: "OpenQuestionsResolver"
---

<objective>
Implement client-side permission dialog components that display when the SDK requests tool approval, allowing users to approve, deny, or approve-always.

Purpose: Give users control over tool execution by showing what Claude wants to do and letting them decide.
Output: PermissionDialog and AskUserDialog components, SSE event handling in useAgentStream, response POST to server.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-permissions-modes/04-RESEARCH.md
@.planning/phases/04-permissions-modes/04-01-SUMMARY.md

# Existing client code
@apps/claude-code-web/client/src/types/agent.ts
@apps/claude-code-web/client/src/hooks/useAgentStream.ts
@apps/claude-code-web/client/src/components/ChatView.tsx

# UI Kit reference
@packages/ui-kit/react-chat/src/components/OpenQuestionsResolver/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add client permission types and event handling</name>
  <files>
    apps/claude-code-web/client/src/types/agent.ts
    apps/claude-code-web/client/src/hooks/useAgentStream.ts
  </files>
  <action>
**In types/agent.ts:**

Add permission-related types:

1. `PermissionMode` type: 'default' | 'plan' | 'acceptEdits' | 'bypassPermissions'

2. `PermissionRequestEvent` interface:
   - type: 'permission_request'
   - requestId: string
   - toolName: string
   - input: Record<string, unknown>
   - timestamp: number

3. `QuestionRequestEvent` interface:
   - type: 'question_request'
   - requestId: string
   - questions: Array of { question: string; options: Array<{ label: string; description?: string }>; multiSelect?: boolean }
   - timestamp: number

4. `ModeChangedEvent` interface:
   - type: 'mode_changed'
   - mode: PermissionMode
   - timestamp: number

5. Add these to an SSEEvent union type

6. Update `UseAgentStreamReturn` interface to add:
   - permissionRequest: PermissionRequestEvent | null
   - questionRequest: QuestionRequestEvent | null
   - permissionMode: PermissionMode
   - respondToPermission: (requestId: string, behavior: 'allow' | 'deny', message?: string) => Promise<void>
   - respondToQuestion: (requestId: string, answers: Record<string, string>) => Promise<void>

**In hooks/useAgentStream.ts:**

1. Add state for:
   - permissionRequest: PermissionRequestEvent | null
   - questionRequest: QuestionRequestEvent | null
   - permissionMode: PermissionMode (initialize from query param or 'default')

2. In the message handler (where SSE events are processed):
   - Add case for 'permission_request': setPermissionRequest(event)
   - Add case for 'question_request': setQuestionRequest(event)
   - Add case for 'mode_changed': setPermissionMode(event.mode)

3. Implement respondToPermission function:
   ```typescript
   const respondToPermission = async (requestId: string, behavior: 'allow' | 'deny', message?: string) => {
     await fetch('/api/agent/permission-response', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ requestId, behavior, message }),
     });
     setPermissionRequest(null);
   };
   ```

4. Implement respondToQuestion function:
   ```typescript
   const respondToQuestion = async (requestId: string, answers: Record<string, string>) => {
     await fetch('/api/agent/question-response', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ requestId, answers }),
     });
     setQuestionRequest(null);
   };
   ```

5. Return new state and functions from the hook

6. Update startStream to accept permissionMode parameter and include in query string
  </action>
  <verify>Build passes: `cd apps/claude-code-web/client && pnpm build`</verify>
  <done>
- Permission types added to agent.ts
- useAgentStream handles permission_request and question_request events
- respondToPermission and respondToQuestion functions implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PermissionDialog component</name>
  <files>
    apps/claude-code-web/client/src/components/PermissionDialog.tsx
    apps/claude-code-web/client/src/components/PermissionDialog.module.css
  </files>
  <action>
**Create PermissionDialog.tsx:**

1. Import Dialog, Button, Text from @ui-kit/react
2. Import Code component for displaying tool input

3. Props interface:
   - open: boolean
   - toolName: string
   - input: Record<string, unknown>
   - onApprove: () => void
   - onDeny: () => void
   - onApproveAlways: () => void

4. Implement formatToolInput helper function:
   - For 'Bash': show "Command: {command}"
   - For 'Write': show "File: {file_path}" and truncated content preview
   - For 'Edit': show "File: {file_path}", "Replace: {old_string}", "With: {new_string}"
   - For 'Read', 'Glob', 'Grep': show relevant parameters
   - Default: JSON.stringify with formatting

5. Render Dialog with:
   - title: "Allow {toolName}?"
   - Content: Text explaining what Claude wants to do + Code block with formatted input
   - Footer with three buttons:
     - "Deny" (variant="ghost", onClick={onDeny})
     - "Always Allow" (variant="secondary", onClick={onApproveAlways})
     - "Allow" (variant="primary", onClick={onApprove})

6. Use escape key to deny (Dialog handles this via onClose)

**Create PermissionDialog.module.css:**

Style the dialog content and action buttons:
- .content: padding, flex column layout
- .actions: flex row, gap between buttons, justify-content: flex-end
- .inputPreview: max-height with overflow scroll for long inputs
  </action>
  <verify>Build passes: `cd apps/claude-code-web/client && pnpm build`</verify>
  <done>PermissionDialog component renders tool name, formatted input, and approve/deny/always-allow buttons</done>
</task>

<task type="auto">
  <name>Task 3: Create AskUserDialog and integrate dialogs into ChatView</name>
  <files>
    apps/claude-code-web/client/src/components/AskUserDialog.tsx
    apps/claude-code-web/client/src/components/ChatView.tsx
  </files>
  <action>
**Create AskUserDialog.tsx:**

1. Import OpenQuestionsResolver and types from @ui-kit/react-chat
2. Import Dialog from @ui-kit/react

3. Props interface:
   - open: boolean
   - questions: Array of { question: string; options: Array<{ label: string; description?: string }>; multiSelect?: boolean }
   - onComplete: (answers: Record<string, string>) => void
   - onDismiss: () => void

4. Transform SDK questions to OpenQuestion format:
   ```typescript
   const openQuestions: OpenQuestion[] = questions.map((q, index) => ({
     id: `q-${index}`,
     question: q.question,
     context: undefined,
     selectionType: q.multiSelect ? 'multiple' : 'single',
     options: q.options.map((opt, optIndex) => ({
       id: `opt-${optIndex}`,
       label: opt.label,
       description: opt.description,
     })),
     allowCustom: true,
   }));
   ```

5. Handle completion:
   - Transform OpenQuestionsResult back to SDK answer format (Record<string, string>)
   - For multi-select: join selected labels with ", "
   - For custom: use customText
   - Call onComplete with answers

6. Render OpenQuestionsResolver directly (not wrapped in Dialog - it has its own UI):
   - questions={openQuestions}
   - onComplete={handleComplete}
   - onDismiss={onDismiss}
   - variant="centered"

**Update ChatView.tsx:**

1. Import PermissionDialog and AskUserDialog components
2. Destructure new values from useConversation (or useAgentStream):
   - permissionRequest
   - questionRequest
   - respondToPermission
   - respondToQuestion

3. Add handlers:
   ```typescript
   const handlePermissionApprove = () => {
     if (permissionRequest) {
       respondToPermission(permissionRequest.requestId, 'allow');
     }
   };

   const handlePermissionDeny = () => {
     if (permissionRequest) {
       respondToPermission(permissionRequest.requestId, 'deny', 'User denied this action');
     }
   };

   const handlePermissionAlwaysAllow = () => {
     // For now, just approve. Rule persistence is Phase 5.
     if (permissionRequest) {
       respondToPermission(permissionRequest.requestId, 'allow');
     }
   };

   const handleQuestionComplete = (answers: Record<string, string>) => {
     if (questionRequest) {
       respondToQuestion(questionRequest.requestId, answers);
     }
   };

   const handleQuestionDismiss = () => {
     if (questionRequest) {
       respondToQuestion(questionRequest.requestId, {});
     }
   };
   ```

4. Render dialogs at the end of the component (before closing fragment):
   ```tsx
   <PermissionDialog
     open={!!permissionRequest}
     toolName={permissionRequest?.toolName ?? ''}
     input={permissionRequest?.input ?? {}}
     onApprove={handlePermissionApprove}
     onDeny={handlePermissionDeny}
     onApproveAlways={handlePermissionAlwaysAllow}
   />
   <AskUserDialog
     open={!!questionRequest}
     questions={questionRequest?.questions ?? []}
     onComplete={handleQuestionComplete}
     onDismiss={handleQuestionDismiss}
   />
   ```
  </action>
  <verify>
1. Build passes: `cd apps/claude-code-web/client && pnpm build`
2. Dev server starts: `cd apps/claude-code-web/client && timeout 5 pnpm dev || true`
  </verify>
  <done>
- AskUserDialog wraps OpenQuestionsResolver with SDK question format transformation
- ChatView renders PermissionDialog and AskUserDialog based on state
- Dialogs POST responses back to server
  </done>
</task>

</tasks>

<verification>
1. Client builds without TypeScript errors
2. Dev server starts without runtime errors
3. PermissionDialog component exports correctly
4. AskUserDialog component exports correctly
5. useAgentStream returns permission state and response functions
</verification>

<success_criteria>
- PermissionDialog shows tool name and formatted input with approve/deny/always-allow buttons
- AskUserDialog renders OpenQuestionsResolver with transformed questions
- useAgentStream handles permission_request and question_request SSE events
- Response functions POST to server endpoints
- ChatView integrates both dialogs
</success_criteria>

<output>
After completion, create `.planning/phases/04-permissions-modes/04-02-SUMMARY.md`
</output>
