---
phase: 07-hooks-system
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/claude-code-web/server/src/hooks/sessionHooks.ts
  - apps/claude-code-web/server/src/hooks/subagentHooks.ts
  - apps/claude-code-web/server/src/hooks/lifecycleHooks.ts
  - apps/claude-code-web/server/src/services/hooksService.ts
autonomous: true

must_haves:
  truths:
    - "SessionStart hooks fire when session begins"
    - "SessionEnd hooks fire when session ends"
    - "SubagentStart/Stop hooks track agent spawning"
    - "UserPromptSubmit hooks can validate and reject input"
    - "PermissionRequest hooks can intercept approval flow"
    - "PreCompact hooks fire before context summarization"
  artifacts:
    - path: "apps/claude-code-web/server/src/hooks/sessionHooks.ts"
      provides: "SessionStart and SessionEnd hook implementations"
      exports: ["createSessionStartHook", "createSessionEndHook"]
    - path: "apps/claude-code-web/server/src/hooks/subagentHooks.ts"
      provides: "SubagentStart and SubagentStop hook implementations"
      exports: ["createSubagentStartHook", "createSubagentStopHook"]
    - path: "apps/claude-code-web/server/src/hooks/lifecycleHooks.ts"
      provides: "UserPromptSubmit, PermissionRequest, PreCompact hooks"
      exports: ["createUserPromptSubmitHook", "createPermissionRequestHook", "createPreCompactHook"]
  key_links:
    - from: "hooksService.ts"
      to: "hooks/sessionHooks.ts"
      via: "import for SessionStart/End"
      pattern: "import.*sessionHooks"
    - from: "hooksService.ts"
      to: "hooks/lifecycleHooks.ts"
      via: "import for lifecycle hooks"
      pattern: "import.*lifecycleHooks"
---

<objective>
Implement lifecycle and permission hooks: session lifecycle, subagent tracking, prompt validation, and compaction hooks.

Purpose: These hooks provide visibility and control over the full agent lifecycle beyond tool execution. SessionStart/End track session boundaries, SubagentStart/Stop track delegated work, UserPromptSubmit validates input, PermissionRequest intercepts approvals, and PreCompact runs before context summarization.

Output: Complete hooks implementation covering requirements HOOK-04, HOOK-05, HOOK-06, HOOK-07, HOOK-08.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-hooks-system/07-RESEARCH.md
@.planning/phases/07-hooks-system/07-01-SUMMARY.md

# Types and service from 07-01
@apps/claude-code-web/server/src/types/hooks.ts
@apps/claude-code-web/server/src/services/hooksService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session lifecycle hooks</name>
  <files>apps/claude-code-web/server/src/hooks/sessionHooks.ts</files>
  <action>
Create sessionHooks.ts with SessionStart and SessionEnd hook implementations.

```typescript
import type {
  HookCallback,
  SessionStartHookInput,
  SessionEndHookInput
} from '../types/hooks.js';

/**
 * Log session start event.
 */
export const logSessionStart: HookCallback = async (input) => {
  if (input.hook_event_name !== 'SessionStart') return {};

  const sessionInput = input as SessionStartHookInput;
  console.log(`[SessionStart] Session ${sessionInput.session_id} started`, {
    source: sessionInput.source,
    cwd: sessionInput.cwd
  });

  return {};
};

/**
 * Log session end event.
 */
export const logSessionEnd: HookCallback = async (input) => {
  if (input.hook_event_name !== 'SessionEnd') return {};

  const sessionInput = input as SessionEndHookInput;
  console.log(`[SessionEnd] Session ${sessionInput.session_id} ended`, {
    reason: sessionInput.reason
  });

  return {};
};

/**
 * Inject context at session start.
 * Useful for providing initial instructions or environment info.
 */
export function createSessionContextHook(context: string): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'SessionStart') return {};

    return {
      hookSpecificOutput: {
        hookEventName: 'SessionStart',
        additionalContext: context
      }
    };
  };
}

/**
 * Run cleanup logic at session end.
 */
export function createSessionCleanupHook(
  cleanup: (sessionId: string, reason: string) => void | Promise<void>
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'SessionEnd') return {};

    const sessionInput = input as SessionEndHookInput;
    await cleanup(sessionInput.session_id, sessionInput.reason);

    return {};
  };
}

/**
 * Create a SessionStart hook from configuration options.
 */
export function createSessionStartHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';

  switch (action) {
    case 'log':
      return logSessionStart;
    case 'inject-context':
      return createSessionContextHook(options?.context as string || '');
    default:
      return logSessionStart;
  }
}

/**
 * Create a SessionEnd hook from configuration options.
 */
export function createSessionEndHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';

  switch (action) {
    case 'log':
      return logSessionEnd;
    default:
      return logSessionEnd;
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify sessionHooks.ts compiles</verify>
  <done>SessionStart/SessionEnd hooks implemented with logging and context injection</done>
</task>

<task type="auto">
  <name>Task 2: Create subagent and lifecycle hooks</name>
  <files>apps/claude-code-web/server/src/hooks/subagentHooks.ts, apps/claude-code-web/server/src/hooks/lifecycleHooks.ts</files>
  <action>
1. Create subagentHooks.ts:

```typescript
import type {
  HookCallback,
  SubagentStartHookInput,
  SubagentStopHookInput
} from '../types/hooks.js';

/**
 * Log subagent spawn event.
 */
export const logSubagentStart: HookCallback = async (input) => {
  if (input.hook_event_name !== 'SubagentStart') return {};

  const agentInput = input as SubagentStartHookInput;
  console.log(`[SubagentStart] Agent ${agentInput.agent_id} spawned`, {
    type: agentInput.agent_type,
    parentSession: agentInput.session_id
  });

  return {};
};

/**
 * Log subagent completion event.
 */
export const logSubagentStop: HookCallback = async (input) => {
  if (input.hook_event_name !== 'SubagentStop') return {};

  const agentInput = input as SubagentStopHookInput;
  console.log(`[SubagentStop] Agent ${agentInput.agent_id} completed`, {
    transcriptPath: agentInput.agent_transcript_path
  });

  return {};
};

/**
 * Track subagent lifecycle for metrics or UI updates.
 */
export function createSubagentTrackerHook(
  onStart: (agentId: string, agentType: string) => void,
  onStop: (agentId: string, transcriptPath: string) => void
): { start: HookCallback; stop: HookCallback } {
  return {
    start: async (input) => {
      if (input.hook_event_name !== 'SubagentStart') return {};
      const agentInput = input as SubagentStartHookInput;
      onStart(agentInput.agent_id, agentInput.agent_type);
      return {};
    },
    stop: async (input) => {
      if (input.hook_event_name !== 'SubagentStop') return {};
      const agentInput = input as SubagentStopHookInput;
      onStop(agentInput.agent_id, agentInput.agent_transcript_path);
      return {};
    }
  };
}

/**
 * Create a SubagentStart hook from configuration options.
 */
export function createSubagentStartHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';
  return action === 'log' ? logSubagentStart : logSubagentStart;
}

/**
 * Create a SubagentStop hook from configuration options.
 */
export function createSubagentStopHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';
  return action === 'log' ? logSubagentStop : logSubagentStop;
}
```

2. Create lifecycleHooks.ts:

```typescript
import type {
  HookCallback,
  UserPromptSubmitHookInput,
  PermissionRequestHookInput,
  PreCompactHookInput
} from '../types/hooks.js';

/**
 * Validate user prompt before submission.
 * Can block prompts containing sensitive patterns.
 */
export function createPromptValidatorHook(
  patterns: RegExp[],
  reason: string
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'UserPromptSubmit') return {};

    const promptInput = input as UserPromptSubmitHookInput;

    for (const pattern of patterns) {
      if (pattern.test(promptInput.prompt)) {
        return {
          continue: false,
          stopReason: reason
        };
      }
    }

    return {};
  };
}

/**
 * Log prompt submission.
 */
export const logPromptSubmit: HookCallback = async (input) => {
  if (input.hook_event_name !== 'UserPromptSubmit') return {};

  const promptInput = input as UserPromptSubmitHookInput;
  console.log(`[UserPromptSubmit] Prompt submitted`, {
    length: promptInput.prompt.length,
    session: promptInput.session_id
  });

  return {};
};

/**
 * Intercept permission request and apply custom logic.
 */
export function createPermissionInterceptHook(
  decide: (toolName: string, input: Record<string, unknown>) => 'allow' | 'deny' | 'ask' | null
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PermissionRequest') return {};

    const permInput = input as PermissionRequestHookInput;
    const decision = decide(permInput.tool_name, permInput.tool_input);

    if (decision) {
      return {
        hookSpecificOutput: {
          hookEventName: 'PermissionRequest',
          permissionDecision: decision
        }
      };
    }

    return {};
  };
}

/**
 * Log permission request.
 */
export const logPermissionRequest: HookCallback = async (input) => {
  if (input.hook_event_name !== 'PermissionRequest') return {};

  const permInput = input as PermissionRequestHookInput;
  console.log(`[PermissionRequest] Tool permission requested`, {
    tool: permInput.tool_name,
    session: permInput.session_id
  });

  return {};
};

/**
 * Run logic before context compaction.
 */
export function createPreCompactHook(
  onCompact: (trigger: string, customInstructions?: string) => void | Promise<void>
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PreCompact') return {};

    const compactInput = input as PreCompactHookInput;
    await onCompact(compactInput.trigger, compactInput.custom_instructions);

    return {};
  };
}

/**
 * Log pre-compact event.
 */
export const logPreCompact: HookCallback = async (input) => {
  if (input.hook_event_name !== 'PreCompact') return {};

  const compactInput = input as PreCompactHookInput;
  console.log(`[PreCompact] Context compaction triggered`, {
    trigger: compactInput.trigger,
    hasCustomInstructions: !!compactInput.custom_instructions
  });

  return {};
};

/**
 * Create a UserPromptSubmit hook from configuration options.
 */
export function createUserPromptSubmitHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';

  switch (action) {
    case 'log':
      return logPromptSubmit;
    case 'validate':
      const patterns = (options?.patterns as string[] || []).map(p => new RegExp(p, 'i'));
      const reason = options?.reason as string || 'Prompt validation failed';
      return createPromptValidatorHook(patterns, reason);
    default:
      return logPromptSubmit;
  }
}

/**
 * Create a PermissionRequest hook from configuration options.
 */
export function createPermissionRequestHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';
  return action === 'log' ? logPermissionRequest : logPermissionRequest;
}

/**
 * Create a PreCompact hook from configuration options.
 */
export function createPreCompactHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';
  return action === 'log' ? logPreCompact : logPreCompact;
}
```
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify both files compile</verify>
  <done>Subagent hooks and lifecycle hooks (UserPromptSubmit, PermissionRequest, PreCompact) implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate all hooks into HooksService</name>
  <files>apps/claude-code-web/server/src/services/hooksService.ts</files>
  <action>
Update hooksService.ts to import and use all hook factories:

```typescript
import { minimatch } from 'minimatch';
import type {
  HooksConfig,
  SDKHooksOptions,
  HookEvent,
  HookCallback,
  HookInput,
  PreToolUseHookInput
} from '../types/hooks.js';
import { createPreToolUseHook } from '../hooks/preToolUseHook.js';
import { createPostToolUseHook } from '../hooks/postToolUseHook.js';
import { createSessionStartHook, createSessionEndHook } from '../hooks/sessionHooks.js';
import { createSubagentStartHook, createSubagentStopHook } from '../hooks/subagentHooks.js';
import {
  createUserPromptSubmitHook,
  createPermissionRequestHook,
  createPreCompactHook
} from '../hooks/lifecycleHooks.js';

export class HooksService {
  private notifyCallback?: (event: {
    hookEvent: string;
    toolName?: string;
    decision?: string;
    reason?: string;
  }) => void;

  /**
   * Set a callback to receive hook activity notifications.
   */
  setNotifyCallback(
    callback: (event: {
      hookEvent: string;
      toolName?: string;
      decision?: string;
      reason?: string;
    }) => void
  ): void {
    this.notifyCallback = callback;
  }

  /**
   * Build SDK-compatible hook callbacks from configuration.
   */
  createHookCallbacks(config: HooksConfig): SDKHooksOptions {
    const hooks: SDKHooksOptions = {};

    for (const [event, matchers] of Object.entries(config)) {
      const hookEvent = event as HookEvent;
      hooks[hookEvent] = matchers.map((m) => ({
        matcher: m.matcher,
        hooks: [
          this.wrapWithNotification(
            this.createCallbackForAction(hookEvent, m.action, m.options),
            hookEvent
          ),
        ],
      }));
    }

    return hooks;
  }

  /**
   * Wrap a hook callback to send notifications.
   */
  private wrapWithNotification(callback: HookCallback, hookEvent: HookEvent): HookCallback {
    return async (input, toolUseID, options) => {
      const result = await callback(input, toolUseID, options);

      // Extract tool name if available
      let toolName: string | undefined;
      if (input.hook_event_name === 'PreToolUse' || input.hook_event_name === 'PostToolUse') {
        toolName = (input as PreToolUseHookInput).tool_name;
      }

      // Notify if callback is registered
      if (this.notifyCallback) {
        this.notifyCallback({
          hookEvent,
          toolName,
          decision: result.hookSpecificOutput?.permissionDecision,
          reason: result.hookSpecificOutput?.permissionDecisionReason,
        });
      }

      return result;
    };
  }

  /**
   * Create a hook callback for a specific event and action.
   */
  private createCallbackForAction(
    event: HookEvent,
    action: string,
    options?: Record<string, unknown>
  ): HookCallback {
    const opts = { ...options, action };

    switch (event) {
      case 'PreToolUse':
        return createPreToolUseHook(opts);
      case 'PostToolUse':
        return createPostToolUseHook(opts);
      case 'SessionStart':
        return createSessionStartHook(opts);
      case 'SessionEnd':
        return createSessionEndHook(opts);
      case 'SubagentStart':
        return createSubagentStartHook(opts);
      case 'SubagentStop':
        return createSubagentStopHook(opts);
      case 'UserPromptSubmit':
        return createUserPromptSubmitHook(opts);
      case 'PermissionRequest':
        return createPermissionRequestHook(opts);
      case 'PreCompact':
        return createPreCompactHook(opts);
      default:
        // For any unhandled events (PostToolUseFailure, Stop, Notification)
        return this.createGenericHook(action, options);
    }
  }

  /**
   * Generic hook implementation for events not yet specialized.
   */
  private createGenericHook(action: string, options?: Record<string, unknown>): HookCallback {
    switch (action) {
      case 'log':
        return async (input) => {
          console.log(`[Hook] ${input.hook_event_name}`, input);
          return {};
        };
      case 'allow':
        return async (input) => ({
          hookSpecificOutput: {
            hookEventName: input.hook_event_name,
            permissionDecision: 'allow' as const,
          },
        });
      case 'deny':
        return async (input) => ({
          hookSpecificOutput: {
            hookEventName: input.hook_event_name,
            permissionDecision: 'deny' as const,
            permissionDecisionReason: (options?.reason as string) || 'Denied by hook',
          },
        });
      default:
        return async () => ({});
    }
  }

  /**
   * Check if a tool name matches a pattern.
   */
  matchesTool(toolName: string, pattern: string): boolean {
    return minimatch(toolName, pattern);
  }
}

export const hooksService = new HooksService();
```

This completes the HooksService with factories for all 9 configurable hook events:
- PreToolUse, PostToolUse (tool hooks)
- SessionStart, SessionEnd (session lifecycle)
- SubagentStart, SubagentStop (subagent lifecycle)
- UserPromptSubmit, PermissionRequest, PreCompact (other lifecycle)

The remaining events (PostToolUseFailure, Stop, Notification) use the generic handler.
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify full compilation succeeds</verify>
  <done>HooksService integrates all hook types with proper factory dispatch</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json`
2. sessionHooks.ts exports SessionStart/End hook factories (HOOK-04)
3. subagentHooks.ts exports SubagentStart/Stop hook factories (HOOK-05)
4. lifecycleHooks.ts exports UserPromptSubmit hook with validation (HOOK-06)
5. lifecycleHooks.ts exports PermissionRequest hook (HOOK-07)
6. lifecycleHooks.ts exports PreCompact hook (HOOK-08)
7. HooksService.createCallbackForAction handles all 9 event types
</verification>

<success_criteria>
- SessionStart/SessionEnd hooks fire on lifecycle events (HOOK-04)
- SubagentStart/SubagentStop hooks track agent spawning (HOOK-05)
- UserPromptSubmit hooks can validate and reject input (HOOK-06)
- PermissionRequest hooks can intercept approval flow (HOOK-07)
- PreCompact hooks run before context summarization (HOOK-08)
- All hooks integrated into HooksService
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-hooks-system/07-03-SUMMARY.md`
</output>
