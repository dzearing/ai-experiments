---
phase: 07-hooks-system
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/claude-code-web/server/src/hooks/preToolUseHook.ts
  - apps/claude-code-web/server/src/hooks/postToolUseHook.ts
  - apps/claude-code-web/server/src/services/hooksService.ts
  - apps/claude-code-web/server/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "PreToolUse hooks can block tool calls by returning deny decision"
    - "PreToolUse hooks can modify tool input via updatedInput"
    - "PostToolUse hooks receive tool response after execution"
    - "Hook matchers filter by tool name using glob patterns"
    - "Hooks can inject system messages for Claude to see"
  artifacts:
    - path: "apps/claude-code-web/server/src/hooks/preToolUseHook.ts"
      provides: "PreToolUse hook implementations"
      exports: ["createPreToolUseHook", "blockDangerousCommands", "autoApproveReadOnly"]
    - path: "apps/claude-code-web/server/src/hooks/postToolUseHook.ts"
      provides: "PostToolUse hook implementations"
      exports: ["createPostToolUseHook", "logToolResult"]
  key_links:
    - from: "hooksService.ts"
      to: "hooks/preToolUseHook.ts"
      via: "import and use in createCallbackForAction"
      pattern: "import.*preToolUseHook"
    - from: "preToolUseHook.ts"
      to: "types/hooks.ts"
      via: "PreToolUseHookInput type"
      pattern: "PreToolUseHookInput"
---

<objective>
Implement PreToolUse and PostToolUse hooks with pattern matching and tool input modification.

Purpose: These hooks intercept tool execution at entry and exit. PreToolUse can block dangerous operations, auto-approve safe ones, modify inputs, and inject context. PostToolUse can log results, trigger notifications, and update state.

Output: Working tool hooks that cover requirements HOOK-01, HOOK-02, HOOK-03, HOOK-09, HOOK-10.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-hooks-system/07-RESEARCH.md
@.planning/phases/07-hooks-system/07-01-SUMMARY.md

# Types and service from 07-01
@apps/claude-code-web/server/src/types/hooks.ts
@apps/claude-code-web/server/src/services/hooksService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PreToolUse hook implementations</name>
  <files>apps/claude-code-web/server/src/hooks/preToolUseHook.ts</files>
  <action>
Create the hooks directory and preToolUseHook.ts file with PreToolUse hook implementations.

```typescript
import type { HookCallback, PreToolUseHookInput, HookJSONOutput } from '../types/hooks.js';

/**
 * Block dangerous bash commands.
 * Matches patterns like rm -rf /, mkfs., dd if=.*of=/dev
 */
export const blockDangerousCommands: HookCallback = async (input, toolUseID, { signal }) => {
  if (input.hook_event_name !== 'PreToolUse') return {};

  const preInput = input as PreToolUseHookInput;
  if (preInput.tool_name !== 'Bash') return {};

  const command = preInput.tool_input.command as string;
  if (!command) return {};

  const dangerousPatterns = [
    /rm\s+-rf\s+\//,
    /rm\s+-fr\s+\//,
    /mkfs\./,
    /dd\s+if=.*of=\/dev/,
    /:\s*\(\)\s*\{\s*:\s*\|\s*:\s*&\s*\}\s*;/,  // Fork bomb
  ];

  for (const pattern of dangerousPatterns) {
    if (pattern.test(command)) {
      return {
        hookSpecificOutput: {
          hookEventName: 'PreToolUse',
          permissionDecision: 'deny',
          permissionDecisionReason: `Blocked dangerous command matching: ${pattern.source}`
        }
      };
    }
  }

  return {};
};

/**
 * Auto-approve read-only tools.
 */
export const autoApproveReadOnly: HookCallback = async (input) => {
  if (input.hook_event_name !== 'PreToolUse') return {};

  const preInput = input as PreToolUseHookInput;
  const readOnlyTools = ['Read', 'Glob', 'Grep'];

  if (readOnlyTools.includes(preInput.tool_name)) {
    return {
      hookSpecificOutput: {
        hookEventName: 'PreToolUse',
        permissionDecision: 'allow',
        permissionDecisionReason: 'Read-only tool auto-approved'
      }
    };
  }

  return {};
};

/**
 * Inject a system message for Claude to see.
 */
export function createSystemMessageHook(message: string): HookCallback {
  return async () => ({
    systemMessage: message
  });
}

/**
 * Modify tool input before execution.
 * Takes a transform function that receives and returns tool input.
 */
export function createInputModifierHook(
  transform: (input: Record<string, unknown>) => Record<string, unknown>
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PreToolUse') return {};

    const preInput = input as PreToolUseHookInput;
    const updatedInput = transform(preInput.tool_input);

    return {
      hookSpecificOutput: {
        hookEventName: 'PreToolUse',
        permissionDecision: 'allow',
        updatedInput
      }
    };
  };
}

/**
 * Block tools matching specific patterns in their input.
 * Used for fine-grained blocking based on arguments.
 */
export function createBlockPatternHook(
  inputKey: string,
  pattern: RegExp,
  reason: string
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PreToolUse') return {};

    const preInput = input as PreToolUseHookInput;
    const value = preInput.tool_input[inputKey];

    if (typeof value === 'string' && pattern.test(value)) {
      return {
        hookSpecificOutput: {
          hookEventName: 'PreToolUse',
          permissionDecision: 'deny',
          permissionDecisionReason: reason
        }
      };
    }

    return {};
  };
}

/**
 * Create a PreToolUse hook from configuration options.
 * This is the main factory used by HooksService.
 */
export function createPreToolUseHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';

  switch (action) {
    case 'block-dangerous':
      return blockDangerousCommands;
    case 'auto-approve-readonly':
      return autoApproveReadOnly;
    case 'inject-message':
      return createSystemMessageHook(options?.message as string || '');
    case 'block-pattern':
      return createBlockPatternHook(
        options?.inputKey as string || 'command',
        new RegExp(options?.pattern as string || ''),
        options?.reason as string || 'Blocked by pattern hook'
      );
    default:
      // Default: log the tool use
      return async (input) => {
        console.log(`[PreToolUse] ${(input as PreToolUseHookInput).tool_name}`, input);
        return {};
      };
  }
}
```

Create the hooks directory first if it doesn't exist:
```bash
mkdir -p apps/claude-code-web/server/src/hooks
```
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify preToolUseHook.ts compiles</verify>
  <done>PreToolUse hooks can block, modify input, and inject system messages</done>
</task>

<task type="auto">
  <name>Task 2: Create PostToolUse hook implementations</name>
  <files>apps/claude-code-web/server/src/hooks/postToolUseHook.ts</files>
  <action>
Create postToolUseHook.ts with PostToolUse hook implementations.

```typescript
import type { HookCallback, PostToolUseHookInput } from '../types/hooks.js';

/**
 * Log tool execution result.
 */
export const logToolResult: HookCallback = async (input) => {
  if (input.hook_event_name !== 'PostToolUse') return {};

  const postInput = input as PostToolUseHookInput;
  console.log(`[PostToolUse] ${postInput.tool_name} completed`, {
    tool: postInput.tool_name,
    inputKeys: Object.keys(postInput.tool_input),
    responseType: typeof postInput.tool_response
  });

  return {};
};

/**
 * Add additional context to Claude based on tool result.
 */
export function createContextInjectionHook(
  contextFn: (input: PostToolUseHookInput) => string | undefined
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PostToolUse') return {};

    const postInput = input as PostToolUseHookInput;
    const context = contextFn(postInput);

    if (context) {
      return {
        hookSpecificOutput: {
          hookEventName: 'PostToolUse',
          additionalContext: context
        }
      };
    }

    return {};
  };
}

/**
 * Track tool execution metrics.
 * Records tool usage for analytics.
 */
export function createMetricsHook(
  recorder: (toolName: string, input: Record<string, unknown>, response: unknown) => void
): HookCallback {
  return async (input) => {
    if (input.hook_event_name !== 'PostToolUse') return {};

    const postInput = input as PostToolUseHookInput;
    recorder(postInput.tool_name, postInput.tool_input, postInput.tool_response);

    return {};
  };
}

/**
 * Create a PostToolUse hook from configuration options.
 * This is the main factory used by HooksService.
 */
export function createPostToolUseHook(options?: Record<string, unknown>): HookCallback {
  const action = options?.action as string || 'log';

  switch (action) {
    case 'log':
      return logToolResult;
    case 'add-context':
      // Simple context injection with static message
      return createContextInjectionHook(() => options?.context as string);
    default:
      return logToolResult;
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify postToolUseHook.ts compiles</verify>
  <done>PostToolUse hooks can log results and inject context</done>
</task>

<task type="auto">
  <name>Task 3: Update HooksService with tool hook factories and add SSE notifications</name>
  <files>apps/claude-code-web/server/src/services/hooksService.ts, apps/claude-code-web/server/src/types/index.ts</files>
  <action>
1. Add HookActivityEvent to types/index.ts:
```typescript
// Hook Activity SSE Event
export interface HookActivityEvent {
  type: 'hook_activity';
  hookEvent: string;
  toolName?: string;
  decision?: 'allow' | 'deny' | 'ask';
  reason?: string;
  timestamp: number;
}

// Add to PermissionSSEEvent union
export type PermissionSSEEvent =
  | PermissionRequestEvent
  | QuestionRequestEvent
  | ModeChangedEvent
  | HookActivityEvent;
```

2. Update hooksService.ts to use the real hook implementations:

```typescript
import { minimatch } from 'minimatch';
import type {
  HooksConfig,
  SDKHooksOptions,
  HookEvent,
  HookCallback,
  HookInput,
  PreToolUseHookInput,
  HookJSONOutput
} from '../types/hooks.js';
import { createPreToolUseHook } from '../hooks/preToolUseHook.js';
import { createPostToolUseHook } from '../hooks/postToolUseHook.js';

export class HooksService {
  private notifyCallback?: (event: { hookEvent: string; toolName?: string; decision?: string; reason?: string }) => void;

  /**
   * Set a callback to receive hook activity notifications.
   * Used for SSE notifications to client.
   */
  setNotifyCallback(callback: (event: { hookEvent: string; toolName?: string; decision?: string; reason?: string }) => void): void {
    this.notifyCallback = callback;
  }

  /**
   * Build SDK-compatible hook callbacks from configuration.
   */
  createHookCallbacks(config: HooksConfig): SDKHooksOptions {
    const hooks: SDKHooksOptions = {};

    for (const [event, matchers] of Object.entries(config)) {
      const hookEvent = event as HookEvent;
      hooks[hookEvent] = matchers.map(m => ({
        matcher: m.matcher,
        hooks: [this.wrapWithNotification(this.createCallbackForAction(hookEvent, m.action, m.options), hookEvent)]
      }));
    }

    return hooks;
  }

  /**
   * Wrap a hook callback to send notifications.
   */
  private wrapWithNotification(callback: HookCallback, hookEvent: HookEvent): HookCallback {
    return async (input, toolUseID, options) => {
      const result = await callback(input, toolUseID, options);

      // Extract tool name if available
      let toolName: string | undefined;
      if (input.hook_event_name === 'PreToolUse' || input.hook_event_name === 'PostToolUse') {
        toolName = (input as PreToolUseHookInput).tool_name;
      }

      // Notify if callback is registered
      if (this.notifyCallback) {
        this.notifyCallback({
          hookEvent,
          toolName,
          decision: result.hookSpecificOutput?.permissionDecision,
          reason: result.hookSpecificOutput?.permissionDecisionReason
        });
      }

      return result;
    };
  }

  /**
   * Create a hook callback for a specific event and action.
   */
  private createCallbackForAction(event: HookEvent, action: string, options?: Record<string, unknown>): HookCallback {
    switch (event) {
      case 'PreToolUse':
        return createPreToolUseHook({ ...options, action });
      case 'PostToolUse':
        return createPostToolUseHook({ ...options, action });
      default:
        // For other events, use generic handlers (implemented in 07-03)
        return this.createGenericHook(action, options);
    }
  }

  /**
   * Generic hook implementation for events not yet specialized.
   */
  private createGenericHook(action: string, options?: Record<string, unknown>): HookCallback {
    switch (action) {
      case 'log':
        return async (input) => {
          console.log(`[Hook] ${input.hook_event_name}`, input);
          return {};
        };
      case 'allow':
        return async (input) => ({
          hookSpecificOutput: {
            hookEventName: input.hook_event_name,
            permissionDecision: 'allow' as const
          }
        });
      case 'deny':
        return async (input) => ({
          hookSpecificOutput: {
            hookEventName: input.hook_event_name,
            permissionDecision: 'deny' as const,
            permissionDecisionReason: (options?.reason as string) || 'Denied by hook'
          }
        });
      default:
        return async () => ({});
    }
  }

  /**
   * Check if a tool name matches a pattern.
   */
  matchesTool(toolName: string, pattern: string): boolean {
    return minimatch(toolName, pattern);
  }
}

export const hooksService = new HooksService();
```
  </action>
  <verify>Run `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json` - verify all compiles. Check HooksService uses hook factories.</verify>
  <done>HooksService creates tool hooks from config and sends notifications</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit -p apps/claude-code-web/server/tsconfig.json`
2. hooks/ directory created with preToolUseHook.ts and postToolUseHook.ts
3. PreToolUse hook can return deny decision (HOOK-01)
4. PostToolUse hook receives tool_response (HOOK-02)
5. Pattern matching via minimatch works (HOOK-03)
6. systemMessage field supported (HOOK-09)
7. updatedInput field supported (HOOK-10)
8. HookActivityEvent type added to SSE events
</verification>

<success_criteria>
- PreToolUse hooks intercept and can block tool calls (HOOK-01)
- PostToolUse hooks run after tool execution (HOOK-02)
- Hook matchers filter by tool name pattern (HOOK-03)
- Hooks can inject system messages (HOOK-09)
- Hooks can modify tool input (HOOK-10)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-hooks-system/07-02-SUMMARY.md`
</output>
