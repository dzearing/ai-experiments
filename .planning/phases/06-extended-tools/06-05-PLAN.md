---
phase: 06-extended-tools
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/claude-code-web/client/src/types/agent.ts
  - apps/claude-code-web/client/src/utils/messageTransformer.ts
  - apps/claude-code-web/client/src/hooks/useAgentStream.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Tool results mark tool calls as completed"
    - "Tools show completion state instead of infinite spinner"
    - "Tool output is displayed after completion"
  artifacts:
    - path: "apps/claude-code-web/client/src/types/agent.ts"
      provides: "ToolResultBlock type definition"
      contains: "type: 'tool_result'"
    - path: "apps/claude-code-web/client/src/utils/messageTransformer.ts"
      provides: "tool_result handling in transformContentBlockToPart"
      contains: "case 'tool_result'"
    - path: "apps/claude-code-web/client/src/hooks/useAgentStream.ts"
      provides: "Tool result matching logic"
      contains: "tool_use_id"
  key_links:
    - from: "messageTransformer.ts"
      to: "useAgentStream.ts"
      via: "tool_result block extraction"
      pattern: "tool_result.*tool_use_id"
---

<objective>
Fix tools stuck with infinite spinners by handling tool_result content blocks.

Purpose: Currently tools never complete because `tool_result` content blocks from SDK are ignored. This makes the app unusable since every tool shows a spinner forever.

Output: Tool calls properly transition from executing to completed state, showing their output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-tools/06-UAT.md

Relevant source files:
@apps/claude-code-web/client/src/types/agent.ts
@apps/claude-code-web/client/src/utils/messageTransformer.ts
@apps/claude-code-web/client/src/hooks/useAgentStream.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ToolResultBlock type to agent types</name>
  <files>apps/claude-code-web/client/src/types/agent.ts</files>
  <action>
Add ToolResultBlock interface to the Content Blocks section:

```typescript
/**
 * Tool result content block indicating a tool execution result.
 * Sent by SDK after a tool completes execution.
 */
export interface ToolResultBlock {
  type: 'tool_result';
  tool_use_id: string;
  content: string;
  is_error?: boolean;
}
```

Update the ContentBlock union type to include ToolResultBlock:

```typescript
export type ContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock;
```

This enables TypeScript to recognize tool_result blocks throughout the codebase.
  </action>
  <verify>Run `npx tsc --noEmit` in apps/claude-code-web/client - no type errors</verify>
  <done>ToolResultBlock type defined and ContentBlock union updated</done>
</task>

<task type="auto">
  <name>Task 2: Handle tool_result in message transformer and stream hook</name>
  <files>
    apps/claude-code-web/client/src/utils/messageTransformer.ts
    apps/claude-code-web/client/src/hooks/useAgentStream.ts
  </files>
  <action>
**In messageTransformer.ts:**

1. Import ToolResultBlock from types if not already imported via ContentBlock.

2. Update `transformContentBlockToPart` to handle tool_result:
   - Add case for 'tool_result' that returns a special marker or null
   - The actual completion logic happens in useAgentStream where we have state access

3. Add new export function `extractToolResults` that takes ContentBlock[] and returns tool results:

```typescript
/**
 * Extracts tool result blocks from content array.
 * Used to match results back to their tool_use calls.
 */
export function extractToolResults(blocks: ContentBlock[]): Array<{
  tool_use_id: string;
  content: string;
  is_error?: boolean;
}> {
  return blocks
    .filter((block): block is ToolResultBlock => block.type === 'tool_result')
    .map(block => ({
      tool_use_id: block.tool_use_id,
      content: block.content,
      is_error: block.is_error,
    }));
}
```

Note: Import ToolResultBlock type if needed: `import type { ToolResultBlock } from '../types/agent';`

**In useAgentStream.ts:**

1. Import `extractToolResults` from messageTransformer.

2. In the `case 'assistant':` block where complete messages are handled (around line 207-294):
   - After creating chatMessage with transformSDKMessage
   - Extract tool results: `const toolResults = extractToolResults(message.message.content);`
   - For each tool result, find the matching tool call in the message parts and update it:

```typescript
// Mark tool calls as completed based on tool_result blocks
if (toolResults.length > 0 && chatMessage.parts) {
  for (const part of chatMessage.parts) {
    if (part.type === 'tool_calls') {
      for (const call of part.calls) {
        // Find matching result by tool_use_id
        // Note: tool_use blocks have 'id' field, tool_result has 'tool_use_id'
        const result = toolResults.find(r => {
          // We need to track the tool_use id - see below
        });
        if (result) {
          call.completed = true;
          call.output = result.content;
          call.endTime = Date.now();
        }
      }
    }
  }
}
```

3. The challenge: tool_use blocks have `id` field but we don't currently preserve it on ChatMessageToolCall. Two options:

   Option A (simpler): Match by index/order - tool_results arrive in same order as tool_use
   Option B (robust): Add `id` field to tool call tracking

   Implement Option A for now since it's simpler:
   - Extract tool_use IDs in order when creating tool calls
   - Match tool_results to tool calls by position

4. Update transformContentBlockToPart to preserve tool_use.id:
   - The ToolUseBlock has an `id` field
   - Add this to the ChatMessageToolCall we create

Actually, looking at the code more carefully:
- The `ToolUseBlock` interface has `id: string`
- But `ChatMessageToolCall` doesn't have an `id` field
- We need to either add `id` to ChatMessageToolCall or use positional matching

For this fix, use positional matching since tool_results arrive in the same order as tool_use blocks.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no type errors
2. Build client: `pnpm build` in apps/claude-code-web/client
  </verify>
  <done>tool_result content blocks are extracted and matched to tool calls, setting completed=true</done>
</task>

<task type="auto">
  <name>Task 3: Track tool_use IDs for robust result matching</name>
  <files>
    apps/claude-code-web/client/src/utils/messageTransformer.ts
    apps/claude-code-web/client/src/hooks/useAgentStream.ts
  </files>
  <action>
The positional matching approach may be fragile if the SDK ever sends results out of order or if there are multiple assistant messages. Implement proper ID-based matching:

**In messageTransformer.ts:**

1. Update the tool_calls creation in `transformContentBlockToPart` to include the tool_use id:

```typescript
case 'tool_use':
  return {
    type: 'tool_calls',
    calls: [{
      id: block.id,  // Add this - preserve the tool_use id
      name: block.name,
      input: block.input,
      completed: false,
      startTime: Date.now(),
    }],
  };
```

Note: ChatMessageToolCall from @ui-kit/react-chat may not have an `id` field. Check the interface - if not, we can use a type extension or store it in a separate tracking map.

If ChatMessageToolCall doesn't support `id`, use the streaming state to track tool IDs:

2. Add to StreamingState:
```typescript
export interface StreamingState {
  currentMessageId: string | null;
  currentText: string;
  currentThinking: string;
  contentBlocks: ContentBlock[];
  toolUseIds: string[];  // Track tool_use IDs in order
}
```

3. Update createInitialStreamingState to include `toolUseIds: []`

4. When accumulating tool_use blocks, push the ID to toolUseIds

**In useAgentStream.ts:**

5. When processing complete assistant message:
   - Get toolUseIds from streaming state before clearing
   - Match tool_results by index: `toolResults[i]` matches `toolUseIds[i]`
   - Use this to find the correct tool call to mark complete
  </action>
  <verify>
1. Run `npx tsc --noEmit` - no type errors
2. Manual test: Start the app, ask Claude to read a file, verify tool shows as completed with output
  </verify>
  <done>Tool results are robustly matched to tool calls using tool_use IDs</done>
</task>

</tasks>

<verification>
After implementation:
1. TypeScript compiles without errors
2. Client builds successfully
3. When Claude executes a tool (Read, Bash, etc.), the UI shows:
   - Spinner while executing
   - Completion state with output when done
   - No more infinite 200+ second timers
</verification>

<success_criteria>
- Tool calls transition from `completed: false` to `completed: true` when results arrive
- Tool output is displayed in the UI
- No more infinite spinners on tool execution
- Build passes with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-tools/06-05-SUMMARY.md`
</output>
