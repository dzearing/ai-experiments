# Plan 01-03: Connection Layer (SSE/WebSocket)

**Phase**: 01 - Infrastructure Foundation
**Estimated complexity**: Medium

## Goal

Establish real-time communication between client and server using Server-Sent Events (SSE), with proper connection management, heartbeat, and cleanup.

## Tasks

### Task 1: Create SSE streaming endpoint on server

**Files**:
- `apps/claude-code-web/server/src/routes/agent.ts`
- `apps/claude-code-web/server/src/index.ts` (modify to add route)

**Action**: Create agent.ts, Modify index.ts

**src/routes/agent.ts:**
```typescript
import { Router, type Request, type Response } from 'express';
import { v4 as uuidv4 } from 'uuid';

export const router = Router();

// Track active connections for cleanup
const activeConnections = new Map<string, { res: Response; heartbeat: NodeJS.Timeout }>();

/**
 * SSE streaming endpoint for agent messages.
 * For Phase 1, this returns test messages to verify the connection works.
 * Actual Agent SDK integration will be added in Phase 2.
 */
router.get('/stream', (req: Request, res: Response) => {
  const connectionId = uuidv4();
  const { prompt } = req.query as { prompt?: string };

  // Set SSE headers
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'X-Accel-Buffering': 'no'
  });

  // Send connection established message
  res.write(`data: ${JSON.stringify({
    type: 'connection',
    connectionId,
    timestamp: new Date().toISOString()
  })}\n\n`);

  // Set up heartbeat to keep connection alive
  const heartbeat = setInterval(() => {
    try {
      res.write(':heartbeat\n\n');
    } catch {
      // Connection closed, cleanup will happen in close handler
      clearInterval(heartbeat);
    }
  }, 30000);

  // Track connection
  activeConnections.set(connectionId, { res, heartbeat });

  // Send test messages if prompt provided (Phase 1 test behavior)
  if (prompt) {
    // Simulate streaming response with delays
    const messages = [
      { type: 'assistant', subtype: 'thinking', text: 'Processing your request...' },
      { type: 'assistant', subtype: 'text', text: `You said: "${prompt}"` },
      { type: 'assistant', subtype: 'text', text: 'This is a test response from the SSE endpoint.' },
      { type: 'result', subtype: 'success', is_error: false }
    ];

    let index = 0;

    const sendNextMessage = () => {
      if (index < messages.length) {
        try {
          res.write(`data: ${JSON.stringify(messages[index])}\n\n`);
          index++;

          if (index < messages.length) {
            setTimeout(sendNextMessage, 500);
          }
        } catch {
          // Connection closed
        }
      }
    };

    setTimeout(sendNextMessage, 100);
  }

  // Cleanup on connection close
  req.on('close', () => {
    const connection = activeConnections.get(connectionId);

    if (connection) {
      clearInterval(connection.heartbeat);
      activeConnections.delete(connectionId);
    }
    console.log(`SSE connection closed: ${connectionId}`);
  });
});

/**
 * Endpoint to get active connection count (for monitoring).
 */
router.get('/connections', (_req: Request, res: Response) => {
  res.json({
    activeConnections: activeConnections.size,
    connectionIds: Array.from(activeConnections.keys())
  });
});
```

**Modification to src/index.ts - add after healthRouter:**
```typescript
import { router as agentRouter } from './routes/agent.js';

// ... existing code ...

// Routes
app.use('/api/health', healthRouter);
app.use('/api/agent', agentRouter);  // Add this line
```

### Task 2: Create useAgentStream React hook

**Files**:
- `apps/claude-code-web/client/src/hooks/useAgentStream.ts`
- `apps/claude-code-web/client/src/types/agent.ts`

**Action**: Create

**src/types/agent.ts:**
```typescript
/**
 * Message types from the Agent SDK SSE stream.
 * This is a simplified version for Phase 1 - full types in Phase 2.
 */
export interface AgentMessage {
  type: 'connection' | 'assistant' | 'result' | 'error';
  subtype?: string;
  connectionId?: string;
  timestamp?: string;
  text?: string;
  is_error?: boolean;
  error?: string;
}

export interface UseAgentStreamReturn {
  messages: AgentMessage[];
  isStreaming: boolean;
  isConnected: boolean;
  error: string | null;
  startStream: (prompt: string) => void;
  stopStream: () => void;
  clearMessages: () => void;
}
```

**src/hooks/useAgentStream.ts:**
```typescript
import { useState, useCallback, useRef } from 'react';
import type { AgentMessage, UseAgentStreamReturn } from '../types/agent';

/**
 * React hook for consuming SSE streams from the agent endpoint.
 * Handles connection lifecycle, message parsing, and cleanup.
 */
export function useAgentStream(): UseAgentStreamReturn {
  const [messages, setMessages] = useState<AgentMessage[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);

  const stopStream = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    setIsStreaming(false);
    setIsConnected(false);
  }, []);

  const startStream = useCallback((prompt: string) => {
    // Close any existing connection
    stopStream();

    setIsStreaming(true);
    setError(null);

    const url = `/api/agent/stream?prompt=${encodeURIComponent(prompt)}`;
    const eventSource = new EventSource(url);

    eventSourceRef.current = eventSource;

    eventSource.onopen = () => {
      setIsConnected(true);
      console.log('SSE connection opened');
    };

    eventSource.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data) as AgentMessage;

        setMessages(prev => [...prev, message]);

        // Check for stream end
        if (message.type === 'result') {
          setIsStreaming(false);
          // Keep connection open for potential follow-up messages
        }

        if (message.type === 'error') {
          setError(message.error || 'Unknown error');
          setIsStreaming(false);
        }
      } catch (parseError) {
        console.error('Failed to parse SSE message:', parseError);
      }
    };

    eventSource.onerror = (event) => {
      console.error('SSE connection error:', event);

      // EventSource will try to reconnect automatically
      // We set error state only if we were not expecting a close
      if (eventSource.readyState === EventSource.CLOSED) {
        setIsConnected(false);
        setIsStreaming(false);

        if (!error) {
          setError('Connection lost');
        }
      }
    };
  }, [stopStream, error]);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  return {
    messages,
    isStreaming,
    isConnected,
    error,
    startStream,
    stopStream,
    clearMessages
  };
}
```

### Task 3: Update ChatView to use SSE connection

**Files**:
- `apps/claude-code-web/client/src/components/ChatView.tsx` (modify)
- `apps/claude-code-web/client/src/components/ChatView.module.css` (modify)

**Action**: Modify

Replace the existing ChatView.tsx with:

```typescript
import { useState, useEffect } from 'react';
import { Button, Input } from '@ui-kit/react';
import { useAgentStream } from '../hooks/useAgentStream';
import styles from './ChatView.module.css';

interface HealthStatus {
  status: string;
  timestamp: string;
  version: string;
}

export function ChatView() {
  const [healthStatus, setHealthStatus] = useState<HealthStatus | null>(null);
  const [healthError, setHealthError] = useState<string | null>(null);
  const [healthLoading, setHealthLoading] = useState(false);
  const [inputValue, setInputValue] = useState('');

  const {
    messages,
    isStreaming,
    isConnected,
    error: streamError,
    startStream,
    clearMessages
  } = useAgentStream();

  const checkHealth = async () => {
    setHealthLoading(true);
    setHealthError(null);

    try {
      const response = await fetch('/api/health');

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();

      setHealthStatus(data);
    } catch (err) {
      setHealthError(err instanceof Error ? err.message : 'Failed to connect');
    } finally {
      setHealthLoading(false);
    }
  };

  useEffect(() => {
    checkHealth();
  }, []);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (inputValue.trim() && !isStreaming) {
      startStream(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <div className={styles.chatView}>
      <div className={styles.statusPanel}>
        <div className={styles.statusHeader}>
          <h2>Server Status</h2>
          <div className={styles.connectionIndicator}>
            <span
              className={`${styles.connectionDot} ${isConnected ? styles.connected : ''}`}
            />
            {isConnected ? 'Connected' : 'Disconnected'}
          </div>
        </div>
        {healthLoading && <p className={styles.loading}>Checking connection...</p>}
        {healthError && (
          <p className={styles.error}>
            Connection error: {healthError}
          </p>
        )}
        {healthStatus && (
          <div className={styles.status}>
            <p>
              <strong>Status:</strong> {healthStatus.status}
            </p>
            <p>
              <strong>Version:</strong> {healthStatus.version}
            </p>
          </div>
        )}
        <Button onClick={checkHealth} disabled={healthLoading}>
          Refresh Status
        </Button>
      </div>

      <div className={styles.chatArea}>
        <div className={styles.messageList}>
          {messages.length === 0 ? (
            <p className={styles.placeholder}>
              Send a message to test the SSE connection
            </p>
          ) : (
            messages.map((msg, index) => (
              <div
                key={index}
                className={`${styles.message} ${styles[msg.type] || ''}`}
              >
                <span className={styles.messageType}>{msg.type}</span>
                {msg.subtype && (
                  <span className={styles.messageSubtype}>({msg.subtype})</span>
                )}
                {msg.text && <p className={styles.messageText}>{msg.text}</p>}
                {msg.connectionId && (
                  <p className={styles.messageMeta}>ID: {msg.connectionId}</p>
                )}
              </div>
            ))
          )}
          {isStreaming && (
            <div className={styles.streamingIndicator}>
              Receiving messages...
            </div>
          )}
          {streamError && (
            <div className={styles.streamError}>
              Stream error: {streamError}
            </div>
          )}
        </div>

        <form onSubmit={handleSubmit} className={styles.inputForm}>
          <Input
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            placeholder="Type a message to test SSE..."
            disabled={isStreaming}
          />
          <Button type="submit" disabled={isStreaming || !inputValue.trim()}>
            Send
          </Button>
          <Button
            type="button"
            onClick={clearMessages}
            disabled={messages.length === 0}
          >
            Clear
          </Button>
        </form>
      </div>
    </div>
  );
}
```

Add these styles to ChatView.module.css:

```css
.chatView {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding: var(--spacing);
  gap: var(--spacing);
}

.statusPanel {
  background: var(--color-panel-background);
  border-radius: var(--radius-card);
  padding: var(--spacing);
  box-shadow: var(--shadow-card);
}

.statusHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-small10);
}

.statusHeader h2 {
  margin: 0;
  font-size: var(--font-size-h3);
  color: var(--color-body-text);
}

.connectionIndicator {
  display: flex;
  align-items: center;
  gap: var(--spacing-small10);
  font-size: var(--font-size-small);
  color: var(--color-body-textSoft10);
}

.connectionDot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--color-danger-background);
}

.connectionDot.connected {
  background: var(--color-success-background);
}

.loading {
  color: var(--color-body-textSoft10);
}

.error {
  color: var(--color-danger-text);
}

.status {
  margin-bottom: var(--spacing);
}

.status p {
  margin: var(--spacing-small10) 0;
  color: var(--color-body-text);
}

.chatArea {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--color-panel-background);
  border-radius: var(--radius-card);
  overflow: hidden;
}

.messageList {
  flex: 1;
  overflow-y: auto;
  padding: var(--spacing);
}

.placeholder {
  color: var(--color-body-textSoft20);
  text-align: center;
  padding: var(--spacing-large10);
}

.message {
  margin-bottom: var(--spacing-small10);
  padding: var(--spacing-small10);
  background: var(--color-body-backgroundSoft05);
  border-radius: var(--radius-button);
}

.message.connection {
  border-left: 3px solid var(--color-info-background);
}

.message.assistant {
  border-left: 3px solid var(--color-primary-background);
}

.message.result {
  border-left: 3px solid var(--color-success-background);
}

.message.error {
  border-left: 3px solid var(--color-danger-background);
}

.messageType {
  font-weight: var(--font-weight-medium);
  color: var(--color-body-text);
}

.messageSubtype {
  margin-left: var(--spacing-small10);
  color: var(--color-body-textSoft10);
  font-size: var(--font-size-small);
}

.messageText {
  margin: var(--spacing-small10) 0 0 0;
  color: var(--color-body-text);
}

.messageMeta {
  margin: var(--spacing-small10) 0 0 0;
  font-size: var(--font-size-small);
  color: var(--color-body-textSoft20);
  font-family: var(--font-family-mono);
}

.streamingIndicator {
  padding: var(--spacing-small10);
  color: var(--color-info-text);
  font-style: italic;
}

.streamError {
  padding: var(--spacing-small10);
  color: var(--color-danger-text);
}

.inputForm {
  display: flex;
  gap: var(--spacing-small10);
  padding: var(--spacing);
  border-top: 1px solid var(--color-body-border);
}

.inputForm input {
  flex: 1;
}
```

## Verification

- [ ] Server: `GET /api/agent/stream` returns SSE headers (`Content-Type: text/event-stream`)
- [ ] Server: SSE connection sends initial `connection` message with `connectionId`
- [ ] Server: Heartbeat comments (`:heartbeat`) sent every 30 seconds
- [ ] Server: Connection cleanup on client disconnect (check `/api/agent/connections` count)
- [ ] Client: `useAgentStream` hook connects and receives messages
- [ ] Client: Connection indicator shows green when connected
- [ ] Client: Messages appear in the message list with proper styling
- [ ] Client: "Receiving messages..." indicator shows during streaming
- [ ] Client: Form input sends prompt and triggers SSE response
- [ ] Client: Clear button removes all messages
- [ ] Full flow: Type message -> Submit -> See streaming response -> Result message ends stream

## Dependencies

- Plan 01-01 (server must exist)
- Plan 01-02 (client must exist with ui-kit integration)
