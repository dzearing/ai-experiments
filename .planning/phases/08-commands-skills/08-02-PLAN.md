---
phase: 08-commands-skills
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - apps/claude-code-web/client/src/hooks/useSlashCommands.ts
  - apps/claude-code-web/client/src/types/commands.ts
  - apps/claude-code-web/client/src/components/ChatView.tsx
autonomous: true

must_haves:
  truths:
    - "Client loads commands from server on mount"
    - "Built-in commands (/help, /clear) are available without server"
    - "Custom commands from .claude/commands/ appear in command palette"
    - "Typing / shows command popover with filtering"
    - "Selecting a command clears input and executes"
  artifacts:
    - path: "apps/claude-code-web/client/src/types/commands.ts"
      provides: "Client-side command types"
      exports: ["CommandDefinition", "BuiltinCommand"]
    - path: "apps/claude-code-web/client/src/hooks/useSlashCommands.ts"
      provides: "Hook for command loading and execution"
      exports: ["useSlashCommands"]
    - path: "apps/claude-code-web/client/src/components/ChatView.tsx"
      provides: "ChatView wired with commands"
      contains: "commands={commands}"
  key_links:
    - from: "apps/claude-code-web/client/src/hooks/useSlashCommands.ts"
      to: "/api/commands"
      via: "fetch on mount"
      pattern: "fetch.*api/commands"
    - from: "apps/claude-code-web/client/src/components/ChatView.tsx"
      to: "useSlashCommands"
      via: "hook usage"
      pattern: "useSlashCommands"
---

<objective>
Create client-side useSlashCommands hook that loads commands from server and provides built-in commands, then wire ChatInput with command support in ChatView.

Purpose: Enable slash command UI by connecting ChatInput's existing command infrastructure with server-loaded custom commands and client-side built-in commands.

Output: useSlashCommands hook and ChatView integration with working command palette.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-commands-skills/08-RESEARCH.md
@.planning/phases/08-commands-skills/08-CONTEXT.md
@.planning/phases/08-commands-skills/08-01-SUMMARY.md
@packages/ui-kit/react-chat/src/components/ChatInput/SlashCommand.types.ts
@apps/ideate/client/src/hooks/useChatCommands.tsx
@apps/claude-code-web/client/src/components/ChatView.tsx
@apps/claude-code-web/client/src/hooks/useConversation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create client command types</name>
  <files>apps/claude-code-web/client/src/types/commands.ts</files>
  <action>
Create client-side command types that mirror server definitions (simplified for client use).

Define:
- `CommandSource`: 'builtin' | 'project' | 'user'
- `CommandDefinition`: Interface with:
  - name: string
  - description: string
  - argumentHint?: string
  - source: CommandSource
  - type: 'command' | 'skill'

These types are used for API responses and internal state.
  </action>
  <verify>TypeScript compiles: `cd apps/claude-code-web/client && pnpm build`</verify>
  <done>Client command types exported from types/commands.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create useSlashCommands hook</name>
  <files>apps/claude-code-web/client/src/hooks/useSlashCommands.ts</files>
  <action>
Create useSlashCommands hook following the useChatCommands pattern from ideate.

Import:
- useState, useEffect, useCallback, useMemo from react
- TrashIcon, HelpIcon from @ui-kit/icons
- SlashCommand, SlashCommandResult from @ui-kit/react-chat
- CommandDefinition from ../types/commands

Define BUILTIN_COMMANDS array of SlashCommand:
- /clear: description "Clear conversation history", icon TrashIcon
- /help: description "Show available commands", icon HelpIcon

Define hook interface:
```typescript
interface UseSlashCommandsOptions {
  clearConversation: () => void;
  addSystemMessage: (content: string) => void;
  contextUsage?: { inputTokens: number; outputTokens: number; cacheReadTokens?: number } | null;
  permissionMode?: string;
}
```

Implement useSlashCommands hook:

1. State: customCommands (CommandDefinition[]), loading (boolean), error (string | null)

2. useEffect to fetch commands on mount:
   - Fetch `/api/commands?cwd=${encodeURIComponent(window.location.pathname || '/')}`
   - For dev, use process.env.VITE_API_URL or default to 'http://localhost:3002'
   - On success, setCustomCommands(data.commands)
   - On error, console.warn and setError

3. commands = useMemo combining:
   - BUILTIN_COMMANDS
   - customCommands mapped to SlashCommand format: { name, description, usage: argumentHint ? `/${name} ${argumentHint}` : `/${name}` }

4. handleCommand callback(command: string, args: string) => SlashCommandResult:
   - 'clear': call clearConversation(), return { handled: true, clearInput: true }
   - 'help': call addSystemMessage with help text listing all commands, return { handled: true, clearInput: true }
   - 'status': show context usage and permission mode info
   - default: For custom commands, return { handled: false } for now (execution in Plan 04)

5. Return: { commands, handleCommand, loading, error }

Helper: generateHelpText(commands) - creates markdown listing all available commands
  </action>
  <verify>TypeScript compiles: `cd apps/claude-code-web/client && pnpm build`</verify>
  <done>useSlashCommands hook exports commands array and handleCommand callback</done>
</task>

<task type="auto">
  <name>Task 3: Wire ChatInput with commands in ChatView</name>
  <files>apps/claude-code-web/client/src/components/ChatView.tsx</files>
  <action>
Update ChatView to use slash commands.

Import useSlashCommands from ../hooks/useSlashCommands.

In ChatView component:

1. Create addSystemMessage callback that adds a system-style message to the chat:
   - Create a ChatPanelMessage with role-like styling (senderName: 'System', isOwn: false)
   - Use a mechanism to display it - either inject into messages or show as separate element
   - For simplicity: add as assistant message with timestamp

2. Call useSlashCommands hook:
```typescript
const { commands, handleCommand } = useSlashCommands({
  clearConversation,
  addSystemMessage,
  contextUsage,
  permissionMode,
});
```

3. Update ChatInput props to include commands:
```typescript
<ChatInput
  onSubmit={handleSubmit}
  commands={commands}
  onCommand={handleCommand}
  disabled={isStreaming}
  placeholder="Message Claude..."
  autoFocus={true}
  fullWidth={true}
/>
```

4. Ensure clearConversation is available from useConversation hook (it is).

Note: addSystemMessage needs to integrate with the existing message display. The simplest approach is to use a local messages state that supplements useConversation messages for system messages from commands.
  </action>
  <verify>
Build passes: `cd apps/claude-code-web && pnpm build`
Manual test: Start dev server, type "/" in input, command popover appears
Manual test: Select /clear, conversation clears
Manual test: Type /help, help message appears
  </verify>
  <done>ChatView displays command popover on "/" and /clear, /help commands work</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Typing "/" in ChatInput shows command popover
3. Arrow keys navigate, Enter/Tab selects command
4. /clear clears the conversation
5. /help shows list of available commands
6. Custom commands from .claude/commands/ appear in popover (if any exist)
</verification>

<success_criteria>
- Command popover appears when typing "/"
- Built-in /clear command works
- Built-in /help command displays available commands
- Custom commands loaded from server appear in palette
- Keyboard navigation works (arrow keys, Enter, Tab, Escape)
</success_criteria>

<output>
After completion, create `.planning/phases/08-commands-skills/08-02-SUMMARY.md`
</output>
