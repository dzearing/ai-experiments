---
phase: 08-commands-skills
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/claude-code-web/server/src/types/commands.ts
  - apps/claude-code-web/server/src/services/commandsService.ts
  - apps/claude-code-web/server/src/routes/commands.ts
  - apps/claude-code-web/server/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Server can load command files from .claude/commands/ directory"
    - "Server can load skill files from .claude/skills/ directory"
    - "Command frontmatter is parsed correctly (description, argument-hint, allowed-tools)"
    - "API endpoint returns command/skill definitions to client"
  artifacts:
    - path: "apps/claude-code-web/server/src/types/commands.ts"
      provides: "CommandDefinition and SkillDefinition types"
      exports: ["CommandDefinition", "SkillDefinition", "CommandSource"]
    - path: "apps/claude-code-web/server/src/services/commandsService.ts"
      provides: "CommandsService class with loadCommands method"
      exports: ["CommandsService", "commandsService"]
    - path: "apps/claude-code-web/server/src/routes/commands.ts"
      provides: "Express router for /api/commands endpoint"
      exports: ["commandsRouter"]
  key_links:
    - from: "apps/claude-code-web/server/src/routes/commands.ts"
      to: "commandsService.loadCommands"
      via: "service method call"
      pattern: "commandsService\\.loadCommands"
    - from: "apps/claude-code-web/server/src/index.ts"
      to: "/api/commands"
      via: "router mount"
      pattern: "app\\.use.*commandsRouter"
---

<objective>
Create server-side CommandsService that discovers and loads slash commands from .claude/commands/*.md and skills from .claude/skills/*/SKILL.md following Claude Code's file format.

Purpose: Enable custom command and skill discovery so users can extend the slash command system with project-specific or user-specific commands, matching Claude Code CLI parity.

Output: CommandsService class with loadCommands method, command types, and /api/commands endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-commands-skills/08-RESEARCH.md
@.planning/phases/08-commands-skills/08-CONTEXT.md
@apps/claude-code-web/server/src/services/configService.ts
@apps/claude-code-web/server/src/types/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command types</name>
  <files>apps/claude-code-web/server/src/types/commands.ts</files>
  <action>
Create TypeScript types for command and skill definitions.

Define:
- `CommandSource`: Union type 'builtin' | 'project' | 'user'
- `CommandDefinition`: Interface with fields:
  - name: string (command name without /)
  - description: string (from frontmatter or first paragraph)
  - argumentHint?: string (from frontmatter 'argument-hint')
  - model?: string (from frontmatter 'model')
  - allowedTools?: string[] (from frontmatter 'allowed-tools', comma-separated)
  - content: string (markdown content after frontmatter)
  - source: CommandSource
  - type: 'command' | 'skill'
  - disableModelInvocation?: boolean (skill-only, from frontmatter)
  - userInvocable?: boolean (default true, from frontmatter)
  - context?: 'fork' (skill-only, for subagent execution)

Export all types.
  </action>
  <verify>TypeScript compiles: `cd apps/claude-code-web/server && pnpm build`</verify>
  <done>CommandDefinition and related types exported from types/commands.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create CommandsService</name>
  <files>apps/claude-code-web/server/src/services/commandsService.ts</files>
  <action>
Create CommandsService class following the pattern from configService.ts.

Import:
- fs/promises, path, os from Node
- glob from 'glob'
- matter from 'gray-matter'
- CommandDefinition from ../types/commands.js

Implement CommandsService class with:

1. `fileExists(path: string): Promise<boolean>` - Check if path exists (copy from configService)

2. `loadCommands(projectRoot: string): Promise<CommandDefinition[]>` - Main method that:
   - Loads from ~/.claude/commands/ (user scope)
   - Loads from {projectRoot}/.claude/commands/ (project scope)
   - Loads from ~/.claude/skills/ (user scope)
   - Loads from {projectRoot}/.claude/skills/ (project scope)
   - Project scope commands override user scope if same name (closer scope wins)

3. `loadFromDirectory(dir: string, source: 'user' | 'project', type: 'command'): Promise<CommandDefinition[]>` - Private method:
   - Use glob('**/*.md', { cwd: dir }) to find all .md files
   - For each file: parse with gray-matter
   - Extract frontmatter fields: description, argument-hint, model, allowed-tools
   - Name is filename without .md extension
   - If no description in frontmatter, extract first paragraph from content

4. `loadSkillsFromDirectory(dir: string, source: 'user' | 'project'): Promise<CommandDefinition[]>` - Private method:
   - Look for */SKILL.md pattern in directory
   - Directory name becomes skill name (unless frontmatter 'name' overrides)
   - Parse SKILL.md frontmatter: description, disable-model-invocation, user-invocable, allowed-tools, model, context

5. `extractFirstParagraph(content: string): string` - Private helper:
   - Return first non-empty paragraph as description
   - Truncate to 100 chars if longer

Export singleton: `export const commandsService = new CommandsService();`
  </action>
  <verify>TypeScript compiles: `cd apps/claude-code-web/server && pnpm build`</verify>
  <done>CommandsService exports loadCommands method that discovers commands from filesystem</done>
</task>

<task type="auto">
  <name>Task 3: Create commands API route and wire to server</name>
  <files>apps/claude-code-web/server/src/routes/commands.ts, apps/claude-code-web/server/src/index.ts</files>
  <action>
Create routes/commands.ts:

Import Router from express, configService, commandsService.

Create router with GET /api/commands endpoint:
- Query param: cwd (required) - working directory
- Use configService.findProjectRoot(cwd) to get project root
- Call commandsService.loadCommands(projectRoot)
- Filter to userInvocable !== false
- Return JSON: { commands: [...] } with each command having:
  - name, description, argumentHint, source, type

Error handling:
- 400 if cwd missing
- 500 on errors with { error: message }

Export: `export const commandsRouter = router;`

Update index.ts:
- Import commandsRouter from './routes/commands.js'
- Add: `app.use('/api/commands', commandsRouter);` alongside other routes
  </action>
  <verify>
Server starts without error: `cd apps/claude-code-web && pnpm dev:server` (start, verify no errors, stop)
Test endpoint manually: Create a test .claude/commands/test.md file, curl the endpoint
  </verify>
  <done>/api/commands endpoint returns discovered commands from filesystem</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Server starts and /api/commands endpoint responds
3. Creating .claude/commands/foo.md makes /foo appear in response
4. Skills in .claude/skills/bar/SKILL.md appear as /bar in response
</verification>

<success_criteria>
- CommandsService discovers commands from ~/.claude/commands/ and {project}/.claude/commands/
- CommandsService discovers skills from ~/.claude/skills/ and {project}/.claude/skills/
- Frontmatter is correctly parsed (description, argument-hint, allowed-tools, model)
- /api/commands?cwd={path} returns array of command definitions
- Project-scope commands have precedence over user-scope when names conflict
</success_criteria>

<output>
After completion, create `.planning/phases/08-commands-skills/08-01-SUMMARY.md`
</output>
